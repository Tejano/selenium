
public class SSISJobDTO {
    private boolean runFlag;
    private String jobName;
    private String source;
    private boolean runStatus;
    private String packageName;
    private String jobStatus;

    // getters and setters
}



In this example, we assume the Excel file has columns in the order: RunFlag, JobName, Source, RunStatus, PackageName, 
and JobStatus. Adjust the column indices accordingly based on your actual Excel structure. 
The method reads the Excel file and populates the SSISJobDTO objects, filtering only the rows with RunFlag set to "Yes".


Implement Excel Reading and DTO Population:

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

@Service
public class ExcelService {
    public List<SSISJobDTO> readExcel(String filePath) {
        List<SSISJobDTO> dtoList = new ArrayList<>();

        try (FileInputStream excelFile = new FileInputStream(new File(filePath));
             Workbook workbook = new XSSFWorkbook(excelFile)) {

            Sheet sheet = workbook.getSheetAt(0);
            Iterator<Row> iterator = sheet.iterator();

            // Skip header row
            if (iterator.hasNext()) {
                iterator.next();
            }

            while (iterator.hasNext()) {
                Row currentRow = iterator.next();

                // Assuming column indices for respective fields
                boolean runFlag = currentRow.getCell(0).getStringCellValue().equalsIgnoreCase("Yes");
                String jobName = currentRow.getCell(1).getStringCellValue();
                String source = currentRow.getCell(2).getStringCellValue();
                boolean runStatus = currentRow.getCell(3).getBooleanCellValue();
                String packageName = currentRow.getCell(4).getStringCellValue();
                String jobStatus = currentRow.getCell(5).getStringCellValue();

                // Only process rows with RunFlag set to "Yes"
                if (runFlag) {
                    SSISJobDTO jobDTO = new SSISJobDTO();
                    jobDTO.setRunFlag(runFlag);
                    jobDTO.setJobName(jobName);
                    jobDTO.setSource(source);
                    jobDTO.setRunStatus(runStatus);
                    jobDTO.setPackageName(packageName);
                    jobDTO.setJobStatus(jobStatus);

                    dtoList.add(jobDTO);
                }
            }
        } catch (IOException e) {
            // Handle IOException
            e.printStackTrace();
        }

        return dtoList;
    }
}




Yes, you can change the cell or row color in Excel using Apache POI. However, please note that the actual color appearance will depend on the viewer (like Microsoft Excel) and may vary.

To change the cell or row color, you'll need to use the CellStyle class in Apache POI. Here's how you can modify the updateExcel method to change the row color based on whether the update was successful or failed:




import org.apache.poi.ss.usermodel.*;

public void updateExcel(String filePath, List<SSISJobDTO> dtoList) {
    try (FileInputStream excelFile = new FileInputStream(new File(filePath));
         Workbook workbook = new XSSFWorkbook(excelFile)) {

        Sheet sheet = workbook.getSheetAt(0);
        CreationHelper creationHelper = workbook.getCreationHelper();

        for (SSISJobDTO jobDTO : dtoList) {
            for (int rowIndex = 1; rowIndex <= sheet.getLastRowNum(); rowIndex++) {
                Row row = sheet.getRow(rowIndex);

                // Assuming jobName is in column 2 (0-based index)
                String jobNameInExcel = row.getCell(1).getStringCellValue();

                if (jobDTO.getJobName().equals(jobNameInExcel)) {
                    Cell jobStatusCell = row.createCell(5); // Assuming jobStatus is in column 6 (0-based index)
                    jobStatusCell.setCellValue(jobDTO.getJobStatus());

                    Cell runFlagCell = row.createCell(0); // Assuming runFlag is in column 1 (0-based index)
                    runFlagCell.setCellValue(jobDTO.isRunFlag() ? "Yes" : "No");

                    // Create a CellStyle with the desired fill color
                    CellStyle style = workbook.createCellStyle();
                    style.setFillForegroundColor(getCellColor(jobDTO));
                    style.setFillPattern(FillPatternType.SOLID_FOREGROUND);

                    // Apply the style to the row
                    row.setRowStyle(style);

                    break;  // Break after updating the corresponding row
                }
            }
        }

        // Save the updated Excel file
        try (FileOutputStream outFile = new FileOutputStream(new File(filePath))) {
            workbook.write(outFile);
        }
    } catch (IOException e) {
        // Handle IOException
        e.printStackTrace();
    }
}

// Helper method to determine the cell color based on success or failure
private short getCellColor(SSISJobDTO jobDTO) {
    if (jobDTO.getRunStatus()) {
        // Light green for success
        return IndexedColors.LIGHT_GREEN.getIndex();
    } else {
        // Light red for failure
        return IndexedColors.LIGHT_CORAL.getIndex();
    }
}

CellStyle Creation:
Instead of creating a new CellStyle for each row, create a CellStyle for each cell 
and set the style for each cell individually. This way, the style will be applied to cells irrespective of whether they are null or have values.

Modify your updateExcel method as follows:
for (SSISJobDTO jobDTO : dtoList) {
    for (int rowIndex = 1; rowIndex <= sheet.getLastRowNum(); rowIndex++) {
        Row row = sheet.getRow(rowIndex);

        // Assuming jobName is in column 2 (0-based index)
        String jobNameInExcel = row.getCell(1).getStringCellValue();

        if (jobDTO.getJobName().equals(jobNameInExcel)) {
            Cell jobStatusCell = row.createCell(5); // Assuming jobStatus is in column 6 (0-based index)
            jobStatusCell.setCellValue(jobDTO.getJobStatus());

            Cell runFlagCell = row.createCell(0); // Assuming runFlag is in column 1 (0-based index)
            runFlagCell.setCellValue(jobDTO.isRunFlag() ? "Yes" : "No");

            // Create a CellStyle with the desired fill color
            CellStyle style = workbook.createCellStyle();
            style.setFillForegroundColor(getCellColor(jobDTO));
            style.setFillPattern(FillPatternType.SOLID_FOREGROUND);

            // Apply the style to the cells
            jobStatusCell.setCellStyle(style);
            runFlagCell.setCellStyle(style);

            break;  // Break after updating the corresponding row
        }
    }
}
In this modified version, we create a CellStyle once and set it for each cell (jobStatusCell and runFlagCell) individually.

Verify Data:
Double-check that the cells with values indeed have the expected values. If they have values, they should be highlighted with the desired colors.

By applying the CellStyle to each cell individually, you should be able to ensure that cells with values are also highlighted correctly.


In this modified version of the updateExcel method:

We create a CellStyle with the desired fill color (light green for success, light red for failure).
We apply this style to the row after updating the cell values.
The getCellColor method determines the color based on the runStatus in the SSISJobDTO. We use the IndexedColors enum from Apache POI to get the color index.
Note that IndexedColors.LIGHT_GREEN.getIndex() and IndexedColors.LIGHT_CORAL.getIndex() return the color index for light green and light red, respectively. 
The actual appearance of colors may vary depending on the viewer used to open the Excel file.


In Apache POI, to access a specific worksheet in a workbook with multiple worksheets, you use the getSheetAt(int index) method of the Workbook class. 
The index parameter is a zero-based index representing the position of the worksheet within the workbook. Here's how you can access a specific worksheet:

import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

// Load the workbook (assuming it's an XLSX workbook)
Workbook workbook = new XSSFWorkbook("path/to/your/file.xlsx");

// Get the first worksheet (index 0)
Sheet firstWorksheet = workbook.getSheetAt(0);

// Get the second worksheet (index 1)
Sheet secondWorksheet = workbook.getSheetAt(1);

// Do something with the worksheets...






In this example, we load an XLSX workbook and then use getSheetAt to access the first and second worksheets. 
Adjust the index according to the specific worksheet you want to access within the workbook.

If you want to access a worksheet by its name (rather than by index), you can use the getSheet(String name) method:

// Get a worksheet by its name
Sheet sheetByName = workbook.getSheet("Sheet1");

// Do something with the worksheet...


Now, let's modify the loop to update a JobStatusDTO for each job:

import java.util.ArrayList;
import java.util.List;

// Assuming SSISRunJob is your class with boolean runFlag, String jobname, String filePath
// Assuming JobStatusDTO is your class to capture job status

List<SSISRunJob> jobs = service.getJobs();
List<JobStatusDTO> jobStatusList = new ArrayList<>();

for (SSISRunJob job : jobs) {
    // Process each job and update its status
    boolean isJobSuccessful = processJob(job);

    // Create a JobStatusDTO for the current job and update its status
    JobStatusDTO jobStatus = new JobStatusDTO();
    jobStatus.setJobName(job.getJobname());
    jobStatus.setJobSuccessful(isJobSuccessful);

    // Add the JobStatusDTO to the list
    jobStatusList.add(jobStatus);
}

// Function to process a job (you'll implement this according to your requirements)
private boolean processJob(SSISRunJob job) {
    // Implement your logic to process the job and determine its success/failure
    // For demonstration, let's assume the job is always successful
    return true;
}




Update the Loop to Set JobStatus and Message:

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

// Inside your loop where you process each job and update its status
for (SSISRunJob job : jobs) {
    boolean isJobSuccessful = processJob(job);
    String jobStatus = isJobSuccessful ? "Completed" : "Failed";
    String message = isJobSuccessful ? "Job was successful." : "Job failed.";

    JobStatusDTO jobStatusDTO = new JobStatusDTO();
    jobStatusDTO.setJobName(job.getJobname());
    jobStatusDTO.setJobSuccessful(isJobSuccessful);
    jobStatusDTO.setJobStatus(jobStatus);
    jobStatusDTO.setMessage(message);

    jobStatusList.add(jobStatusDTO);
}


Update Excel Spreadsheet Based on JobStatusDTO:


try {
    // Load your existing Excel file
    FileInputStream excelFile = new FileInputStream(new File("path/to/your/excel/file.xlsx"));
    Workbook workbook = new XSSFWorkbook(excelFile);
    Sheet sheet = workbook.getSheetAt(0); // Assuming your sheet is at index 0

    for (JobStatusDTO jobStatusDTO : jobStatusList) {
        String jobName = jobStatusDTO.getJobName();
        String status = jobStatusDTO.getJobStatus();
        String message = jobStatusDTO.getMessage();

        // Iterate through the rows and find the row with the matching jobName
        for (Row row : sheet) {
            Cell cell = row.getCell(0); // Assuming jobName is in the first column

            if (cell != null && cell.getStringCellValue().equals(jobName)) {
                // Update job status and message in the respective columns
                row.createCell(1).setCellValue(status);   // Assuming status is in the second column
                row.createCell(2).setCellValue(message);  // Assuming message is in the third column
                break; // Stop searching once job is found
            }
        }
    }

    // Write the updated data to the Excel file
    FileOutputStream outputStream = new FileOutputStream("path/to/your/excel/file.xlsx");
    workbook.write(outputStream);
    workbook.close();
    outputStream.close();

} catch (Exception e) {
    e.printStackTrace();
}


